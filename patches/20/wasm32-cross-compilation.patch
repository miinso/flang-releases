diff --git a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
index eaa1de7..1cf7be2 100644
--- a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
+++ b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
@@ -22,9 +22,13 @@
 #include "flang/Optimizer/Builder/FIRBuilder.h"
 #include "flang/Optimizer/Dialect/FIRDialect.h"
 #include "flang/Optimizer/Dialect/FIRType.h"
+#include "flang/Optimizer/Dialect/Support/FIRContext.h"
 #include "flang/Runtime/reduce.h"
+#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/MLIRContext.h"
+#include "mlir/Interfaces/DataLayoutInterfaces.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/ADT/SmallVector.h"
 #include <cstdint>
 #include <functional>
@@ -53,6 +57,17 @@ namespace fir::runtime {
 using TypeBuilderFunc = mlir::Type (*)(mlir::MLIRContext *);
 using FuncTypeBuilderFunc = mlir::FunctionType (*)(mlir::MLIRContext *);
 
+//===----------------------------------------------------------------------===//
+// Target-aware type size helpers for cross-compilation
+//===----------------------------------------------------------------------===//
+
+/// size_t matches pointer size on all common platforms (LP64, ILP32, LLP64).
+inline unsigned getTargetSizeTBitwidth(mlir::MLIRContext *context,
+                                       const mlir::DataLayout &dl) {
+  auto ptrType = mlir::LLVM::LLVMPointerType::get(context);
+  return dl.getTypeSizeInBits(ptrType);
+}
+
 #define REDUCTION_REF_OPERATION_MODEL(T)                                       \
   template <>                                                                  \
   constexpr TypeBuilderFunc                                                    \
@@ -662,6 +677,77 @@ getModel<Fortran::runtime::ReductionDerivedTypeOperation>() {
   };
 }
 
+//===----------------------------------------------------------------------===//
+// DataLayout-aware type builders for cross-compilation
+//===----------------------------------------------------------------------===//
+
+/// primary template - most types don't need DataLayout, delegate to getModel
+template <typename T>
+struct DLGetModel {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &,
+                        const llvm::Triple &) {
+    return getModel<T>()(context);
+  }
+};
+
+// NOTE: we intentionally do NOT specialize DLGetModel<long> (signed).
+// On LP64 (linux), int64_t = long. Narrowing long would incorrectly
+// shrink int64_t params like OutputInteger64. Only unsigned types
+// used for size_t are specialized below.
+
+/// unsigned long - matches size_t on LP64 (linux/mac 64-bit).
+/// On ILP32 (wasm32) and LLP64 (windows), unsigned long is already 32-bit.
+template <>
+struct DLGetModel<unsigned long> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    return mlir::IntegerType::get(context, getTargetSizeTBitwidth(context, dl));
+  }
+};
+
+template <>
+struct DLGetModel<unsigned long *> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &triple) {
+    return fir::ReferenceType::get(
+        DLGetModel<unsigned long>::get(context, dl, triple));
+  }
+};
+
+template <>
+struct DLGetModel<const unsigned long *> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &triple) {
+    return DLGetModel<unsigned long *>::get(context, dl, triple);
+  }
+};
+
+/// unsigned long long - matches size_t on LLP64 (windows 64-bit).
+/// On LP64 this also catches uint64_t, but no IO runtime funcs use uint64_t.
+template <>
+struct DLGetModel<unsigned long long> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    return mlir::IntegerType::get(context, getTargetSizeTBitwidth(context, dl));
+  }
+};
+
+/// ReductionCharOperation<CHAR> - function ptr with std::size_t parameters
+template <typename CHAR>
+struct DLGetModel<Fortran::runtime::ReductionCharOperation<CHAR>> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    auto charTy = getModel<CHAR>()(context);
+    auto voidTy = fir::LLVMPointerType::get(context,
+                                            mlir::IntegerType::get(context, 8));
+    auto sizeTy = mlir::IntegerType::get(context,
+                                         getTargetSizeTBitwidth(context, dl));
+    auto refTy = fir::ReferenceType::get(charTy);
+    return mlir::FunctionType::get(
+        context, {refTy, sizeTy, refTy, refTy, sizeTy, sizeTy}, voidTy);
+  }
+};
+
 template <typename...>
 struct RuntimeTableKey;
 template <typename RT, typename... ATs>
@@ -679,6 +765,18 @@ struct RuntimeTableKey<RT(ATs...)> {
       return mlir::FunctionType::get(ctxt, argTys, {retTy});
     };
   }
+
+  /// DataLayout-aware type model for cross-compilation support.
+  static mlir::FunctionType getTypeModelDL(mlir::MLIRContext *ctxt,
+                                           const mlir::DataLayout &dl,
+                                           const llvm::Triple &triple) {
+    mlir::Type retTy = DLGetModel<RT>::get(ctxt, dl, triple);
+    llvm::SmallVector<mlir::Type, sizeof...(ATs)> argTys = {
+        DLGetModel<ATs>::get(ctxt, dl, triple)...};
+    if (mlir::isa<mlir::NoneType>(retTy))
+      return mlir::FunctionType::get(ctxt, argTys, {});
+    return mlir::FunctionType::get(ctxt, argTys, {retTy});
+  }
 };
 
 //===----------------------------------------------------------------------===//
@@ -728,6 +826,11 @@ struct RuntimeTableEntry<RuntimeTableKey<KT>, RuntimeIdentifier<Cs...>> {
   static constexpr FuncTypeBuilderFunc getTypeModel() {
     return RuntimeTableKey<KT>::getTypeModel();
   }
+  static mlir::FunctionType getTypeModelDL(mlir::MLIRContext *ctxt,
+                                           const mlir::DataLayout &dl,
+                                           const llvm::Triple &triple) {
+    return RuntimeTableKey<KT>::getTypeModelDL(ctxt, dl, triple);
+  }
   static constexpr const char name[sizeof...(Cs) + 1] = {Cs..., '\0'};
 };
 
@@ -767,8 +870,43 @@ struct RuntimeTableEntry<RuntimeTableKey<KT>, RuntimeIdentifier<Cs...>> {
 #define mkRTKey(X) FirmkKey(RTNAME(X))
 #define EXPAND_AND_QUOTE_KEY(S) ExpandAndQuoteKey(RTNAME(S))
 
-/// Get (or generate) the MLIR FuncOp for a given runtime function. Its template
-/// argument is intended to be of the form: <mkRTKey(runtime function name)>.
+namespace detail {
+/// SFINAE helper to detect if a type has getTypeModelDL.
+template <typename T, typename = void>
+struct HasGetTypeModelDL : std::false_type {};
+
+template <typename T>
+struct HasGetTypeModelDL<
+    T, std::void_t<decltype(T::getTypeModelDL(
+           std::declval<mlir::MLIRContext *>(),
+           std::declval<const mlir::DataLayout &>(),
+           std::declval<const llvm::Triple &>()))>> : std::true_type {};
+
+/// DataLayout-aware function type builder (when RuntimeEntry has getTypeModelDL)
+template <typename RuntimeEntry>
+static mlir::FunctionType
+getFunctionType(fir::FirOpBuilder &builder,
+                std::enable_if_t<HasGetTypeModelDL<RuntimeEntry>::value> * =
+                    nullptr) {
+  auto module = builder.getModule();
+  return RuntimeEntry::getTypeModelDL(builder.getContext(),
+                                      builder.getDataLayout(),
+                                      fir::getTargetTriple(module));
+}
+
+/// Fallback when RuntimeEntry doesn't have getTypeModelDL
+template <typename RuntimeEntry>
+static mlir::FunctionType
+getFunctionType(fir::FirOpBuilder &builder,
+                std::enable_if_t<!HasGetTypeModelDL<RuntimeEntry>::value> * =
+                    nullptr) {
+  return RuntimeEntry::getTypeModel()(builder.getContext());
+}
+} // namespace detail
+
+/// Get (or generate) the MLIR FuncOp for a given runtime function.
+/// Uses DataLayout-aware type building when available to correctly handle
+/// cross-compilation scenarios (e.g. sizeof(size_t) differs between targets).
 template <typename RuntimeEntry>
 static mlir::func::FuncOp getRuntimeFunc(mlir::Location loc,
                                          fir::FirOpBuilder &builder) {
@@ -777,7 +915,7 @@ static mlir::func::FuncOp getRuntimeFunc(mlir::Location loc,
   auto func = builder.getNamedFunction(name);
   if (func)
     return func;
-  auto funTy = RuntimeEntry::getTypeModel()(builder.getContext());
+  auto funTy = detail::getFunctionType<RuntimeEntry>(builder);
   func = builder.createFunction(loc, name, funTy);
   func->setAttr(FIROpsDialect::getFirRuntimeAttrName(), builder.getUnitAttr());
   return func;
diff --git a/flang/lib/Lower/IO.cpp b/flang/lib/Lower/IO.cpp
index 7545372..c59f50a 100644
--- a/flang/lib/Lower/IO.cpp
+++ b/flang/lib/Lower/IO.cpp
@@ -180,7 +180,7 @@ static mlir::func::FuncOp getIORuntimeFunc(mlir::Location loc,
   mlir::func::FuncOp func = builder.getNamedFunction(name);
   if (func)
     return func;
-  auto funTy = getTypeModel<E>()(builder.getContext());
+  auto funTy = fir::runtime::detail::getFunctionType<E>(builder);
   func = builder.createFunction(loc, name, funTy);
   func->setAttr(fir::FIROpsDialect::getFirRuntimeAttrName(),
                 builder.getUnitAttr());
diff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
index 1b078be..7147dc2 100644
--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp
+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
@@ -46,6 +46,7 @@
 #include "mlir/Dialect/GPU/IR/GPUDialect.h"
 #include "mlir/Dialect/LLVMIR/LLVMAttrs.h"
 #include "mlir/Dialect/LLVMIR/LLVMDialect.h"
+#include "mlir/Interfaces/DataLayoutInterfaces.h"
 #include "mlir/Dialect/LLVMIR/Transforms/AddComdats.h"
 #include "mlir/Dialect/OpenACC/OpenACC.h"
 #include "mlir/Dialect/OpenMP/OpenMPDialect.h"
@@ -949,7 +950,11 @@ getMallocInModule(ModuleOp mod, fir::AllocMemOp op,
     return mlir::SymbolRefAttr::get(userMalloc);
 
   mlir::OpBuilder moduleBuilder(mod.getBodyRegion());
-  auto indexType = mlir::IntegerType::get(op.getContext(), 64);
+  // use target ptr width for malloc size (wasm32=32, x86_64=64)
+  mlir::DataLayout dl(op->getParentOfType<mlir::ModuleOp>());
+  auto ptrTy = mlir::LLVM::LLVMPointerType::get(op.getContext());
+  unsigned ptrBits = dl.getTypeSizeInBits(ptrTy);
+  auto indexType = mlir::IntegerType::get(op.getContext(), ptrBits);
   auto mallocDecl = moduleBuilder.create<mlir::LLVM::LLVMFuncOp>(
       op.getLoc(), mallocName,
       mlir::LLVM::LLVMFunctionType::get(getLlvmPtrType(op.getContext()),
diff --git a/flang/lib/Optimizer/CodeGen/Target.cpp b/flang/lib/Optimizer/CodeGen/Target.cpp
index 2a1eb0b..d6eeee0 100644
--- a/flang/lib/Optimizer/CodeGen/Target.cpp
+++ b/flang/lib/Optimizer/CodeGen/Target.cpp
@@ -1656,6 +1656,41 @@ struct TargetLoongArch64 : public GenericTarget<TargetLoongArch64> {
 };
 } // namespace
 
+
+//===----------------------------------------------------------------------===//
+// WebAssembly (wasm32) target specifics.
+//===----------------------------------------------------------------------===//
+
+namespace {
+struct TargetWasm32 : public GenericTarget<TargetWasm32> {
+  using GenericTarget::GenericTarget;
+
+  static constexpr int defaultWidth = 32;
+
+  CodeGenSpecifics::Marshalling
+  complexArgumentType(mlir::Location, mlir::Type eleTy) const override {
+    assert(fir::isa_real(eleTy));
+    CodeGenSpecifics::Marshalling marshal;
+    auto structTy =
+        mlir::TupleType::get(eleTy.getContext(), mlir::TypeRange{eleTy, eleTy});
+    marshal.emplace_back(fir::ReferenceType::get(structTy),
+                         AT{/*alignment=*/4, /*byval=*/true});
+    return marshal;
+  }
+
+  CodeGenSpecifics::Marshalling
+  complexReturnType(mlir::Location loc, mlir::Type eleTy) const override {
+    assert(fir::isa_real(eleTy));
+    CodeGenSpecifics::Marshalling marshal;
+    auto structTy = mlir::TupleType::get(eleTy.getContext(),
+                                          mlir::TypeRange{eleTy, eleTy});
+    marshal.emplace_back(fir::ReferenceType::get(structTy),
+                          AT{/*alignment=*/4, /*byval=*/false, /*sret=*/true});
+    return marshal;
+  }
+};
+} // namespace
+
 // Instantiate the overloaded target instance based on the triple value.
 // TODO: Add other targets to this file as needed.
 std::unique_ptr<fir::CodeGenSpecifics>
@@ -1711,6 +1746,9 @@ fir::CodeGenSpecifics::get(mlir::MLIRContext *ctx, llvm::Triple &&trp,
   case llvm::Triple::ArchType::loongarch64:
     return std::make_unique<TargetLoongArch64>(
         ctx, std::move(trp), std::move(kindMap), targetCPU, targetFeatures, dl);
+  case llvm::Triple::ArchType::wasm32:
+    return std::make_unique<TargetWasm32>(
+        ctx, std::move(trp), std::move(kindMap), targetCPU, targetFeatures, dl);
   }
   TODO(mlir::UnknownLoc::get(ctx), "target not implemented");
 }
