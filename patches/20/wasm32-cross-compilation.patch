diff --git a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
index eaa1de761..1cf7be2ec 100644
--- a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
+++ b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h
@@ -22,9 +22,13 @@
 #include "flang/Optimizer/Builder/FIRBuilder.h"
 #include "flang/Optimizer/Dialect/FIRDialect.h"
 #include "flang/Optimizer/Dialect/FIRType.h"
+#include "flang/Optimizer/Dialect/Support/FIRContext.h"
 #include "flang/Runtime/reduce.h"
+#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/MLIRContext.h"
+#include "mlir/Interfaces/DataLayoutInterfaces.h"
+#include "llvm/TargetParser/Triple.h"
 #include "llvm/ADT/SmallVector.h"
 #include <cstdint>
 #include <functional>
@@ -53,6 +57,17 @@ namespace fir::runtime {
 using TypeBuilderFunc = mlir::Type (*)(mlir::MLIRContext *);
 using FuncTypeBuilderFunc = mlir::FunctionType (*)(mlir::MLIRContext *);
 
+//===----------------------------------------------------------------------===//
+// Target-aware type size helpers for cross-compilation
+//===----------------------------------------------------------------------===//
+
+/// size_t matches pointer size on all common platforms (LP64, ILP32, LLP64).
+inline unsigned getTargetSizeTBitwidth(mlir::MLIRContext *context,
+                                       const mlir::DataLayout &dl) {
+  auto ptrType = mlir::LLVM::LLVMPointerType::get(context);
+  return dl.getTypeSizeInBits(ptrType);
+}
+
 #define REDUCTION_REF_OPERATION_MODEL(T)                                       \
   template <>                                                                  \
   constexpr TypeBuilderFunc                                                    \
@@ -662,6 +677,77 @@ getModel<Fortran::runtime::ReductionDerivedTypeOperation>() {
   };
 }
 
+//===----------------------------------------------------------------------===//
+// DataLayout-aware type builders for cross-compilation
+//===----------------------------------------------------------------------===//
+
+/// primary template - most types don't need DataLayout, delegate to getModel
+template <typename T>
+struct DLGetModel {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &,
+                        const llvm::Triple &) {
+    return getModel<T>()(context);
+  }
+};
+
+// NOTE: we intentionally do NOT specialize DLGetModel<long> (signed).
+// On LP64 (linux), int64_t = long. Narrowing long would incorrectly
+// shrink int64_t params like OutputInteger64. Only unsigned types
+// used for size_t are specialized below.
+
+/// unsigned long - matches size_t on LP64 (linux/mac 64-bit).
+/// On ILP32 (wasm32) and LLP64 (windows), unsigned long is already 32-bit.
+template <>
+struct DLGetModel<unsigned long> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    return mlir::IntegerType::get(context, getTargetSizeTBitwidth(context, dl));
+  }
+};
+
+template <>
+struct DLGetModel<unsigned long *> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &triple) {
+    return fir::ReferenceType::get(
+        DLGetModel<unsigned long>::get(context, dl, triple));
+  }
+};
+
+template <>
+struct DLGetModel<const unsigned long *> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &triple) {
+    return DLGetModel<unsigned long *>::get(context, dl, triple);
+  }
+};
+
+/// unsigned long long - matches size_t on LLP64 (windows 64-bit).
+/// On LP64 this also catches uint64_t, but no IO runtime funcs use uint64_t.
+template <>
+struct DLGetModel<unsigned long long> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    return mlir::IntegerType::get(context, getTargetSizeTBitwidth(context, dl));
+  }
+};
+
+/// ReductionCharOperation<CHAR> - function ptr with std::size_t parameters
+template <typename CHAR>
+struct DLGetModel<Fortran::runtime::ReductionCharOperation<CHAR>> {
+  static mlir::Type get(mlir::MLIRContext *context, const mlir::DataLayout &dl,
+                        const llvm::Triple &) {
+    auto charTy = getModel<CHAR>()(context);
+    auto voidTy = fir::LLVMPointerType::get(context,
+                                            mlir::IntegerType::get(context, 8));
+    auto sizeTy = mlir::IntegerType::get(context,
+                                         getTargetSizeTBitwidth(context, dl));
+    auto refTy = fir::ReferenceType::get(charTy);
+    return mlir::FunctionType::get(
+        context, {refTy, sizeTy, refTy, refTy, sizeTy, sizeTy}, voidTy);
+  }
+};
+
 template <typename...>
 struct RuntimeTableKey;
 template <typename RT, typename... ATs>
@@ -679,6 +765,18 @@ struct RuntimeTableKey<RT(ATs...)> {
       return mlir::FunctionType::get(ctxt, argTys, {retTy});
     };
   }
+
+  /// DataLayout-aware type model for cross-compilation support.
+  static mlir::FunctionType getTypeModelDL(mlir::MLIRContext *ctxt,
+                                           const mlir::DataLayout &dl,
+                                           const llvm::Triple &triple) {
+    mlir::Type retTy = DLGetModel<RT>::get(ctxt, dl, triple);
+    llvm::SmallVector<mlir::Type, sizeof...(ATs)> argTys = {
+        DLGetModel<ATs>::get(ctxt, dl, triple)...};
+    if (mlir::isa<mlir::NoneType>(retTy))
+      return mlir::FunctionType::get(ctxt, argTys, {});
+    return mlir::FunctionType::get(ctxt, argTys, {retTy});
+  }
 };
 
 //===----------------------------------------------------------------------===//
@@ -728,6 +826,11 @@ struct RuntimeTableEntry<RuntimeTableKey<KT>, RuntimeIdentifier<Cs...>> {
   static constexpr FuncTypeBuilderFunc getTypeModel() {
     return RuntimeTableKey<KT>::getTypeModel();
   }
+  static mlir::FunctionType getTypeModelDL(mlir::MLIRContext *ctxt,
+                                           const mlir::DataLayout &dl,
+                                           const llvm::Triple &triple) {
+    return RuntimeTableKey<KT>::getTypeModelDL(ctxt, dl, triple);
+  }
   static constexpr const char name[sizeof...(Cs) + 1] = {Cs..., '\0'};
 };
 
@@ -767,8 +870,43 @@ struct RuntimeTableEntry<RuntimeTableKey<KT>, RuntimeIdentifier<Cs...>> {
 #define mkRTKey(X) FirmkKey(RTNAME(X))
 #define EXPAND_AND_QUOTE_KEY(S) ExpandAndQuoteKey(RTNAME(S))
 
-/// Get (or generate) the MLIR FuncOp for a given runtime function. Its template
-/// argument is intended to be of the form: <mkRTKey(runtime function name)>.
+namespace detail {
+/// SFINAE helper to detect if a type has getTypeModelDL.
+template <typename T, typename = void>
+struct HasGetTypeModelDL : std::false_type {};
+
+template <typename T>
+struct HasGetTypeModelDL<
+    T, std::void_t<decltype(T::getTypeModelDL(
+           std::declval<mlir::MLIRContext *>(),
+           std::declval<const mlir::DataLayout &>(),
+           std::declval<const llvm::Triple &>()))>> : std::true_type {};
+
+/// DataLayout-aware function type builder (when RuntimeEntry has getTypeModelDL)
+template <typename RuntimeEntry>
+static mlir::FunctionType
+getFunctionType(fir::FirOpBuilder &builder,
+                std::enable_if_t<HasGetTypeModelDL<RuntimeEntry>::value> * =
+                    nullptr) {
+  auto module = builder.getModule();
+  return RuntimeEntry::getTypeModelDL(builder.getContext(),
+                                      builder.getDataLayout(),
+                                      fir::getTargetTriple(module));
+}
+
+/// Fallback when RuntimeEntry doesn't have getTypeModelDL
+template <typename RuntimeEntry>
+static mlir::FunctionType
+getFunctionType(fir::FirOpBuilder &builder,
+                std::enable_if_t<!HasGetTypeModelDL<RuntimeEntry>::value> * =
+                    nullptr) {
+  return RuntimeEntry::getTypeModel()(builder.getContext());
+}
+} // namespace detail
+
+/// Get (or generate) the MLIR FuncOp for a given runtime function.
+/// Uses DataLayout-aware type building when available to correctly handle
+/// cross-compilation scenarios (e.g. sizeof(size_t) differs between targets).
 template <typename RuntimeEntry>
 static mlir::func::FuncOp getRuntimeFunc(mlir::Location loc,
                                          fir::FirOpBuilder &builder) {
@@ -777,7 +915,7 @@ static mlir::func::FuncOp getRuntimeFunc(mlir::Location loc,
   auto func = builder.getNamedFunction(name);
   if (func)
     return func;
-  auto funTy = RuntimeEntry::getTypeModel()(builder.getContext());
+  auto funTy = detail::getFunctionType<RuntimeEntry>(builder);
   func = builder.createFunction(loc, name, funTy);
   func->setAttr(FIROpsDialect::getFirRuntimeAttrName(), builder.getUnitAttr());
   return func;
diff --git a/flang/include/flang/Optimizer/CodeGen/FIROpPatterns.h b/flang/include/flang/Optimizer/CodeGen/FIROpPatterns.h
index 35749dae5..495477ee9 100644
--- a/flang/include/flang/Optimizer/CodeGen/FIROpPatterns.h
+++ b/flang/include/flang/Optimizer/CodeGen/FIROpPatterns.h
@@ -173,6 +173,10 @@ protected:
         this->getTypeConverter());
   }
 
+  const mlir::DataLayout &getDataLayout() const {
+    return lowerTy().getDataLayout();
+  }
+
   void attachTBAATag(mlir::LLVM::AliasAnalysisOpInterface op,
                      mlir::Type baseFIRType, mlir::Type accessFIRType,
                      mlir::LLVM::GEPOp gep) const {
diff --git a/flang/lib/Lower/IO.cpp b/flang/lib/Lower/IO.cpp
index 75453721d..c59f50ad7 100644
--- a/flang/lib/Lower/IO.cpp
+++ b/flang/lib/Lower/IO.cpp
@@ -180,7 +180,7 @@ static mlir::func::FuncOp getIORuntimeFunc(mlir::Location loc,
   mlir::func::FuncOp func = builder.getNamedFunction(name);
   if (func)
     return func;
-  auto funTy = getTypeModel<E>()(builder.getContext());
+  auto funTy = fir::runtime::detail::getFunctionType<E>(builder);
   func = builder.createFunction(loc, name, funTy);
   func->setAttr(fir::FIROpsDialect::getFirRuntimeAttrName(),
                 builder.getUnitAttr());
diff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
index 1b078be7b..ac05c70b0 100644
--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp
+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
@@ -49,6 +49,7 @@
 #include "mlir/Dialect/LLVMIR/Transforms/AddComdats.h"
 #include "mlir/Dialect/OpenACC/OpenACC.h"
 #include "mlir/Dialect/OpenMP/OpenMPDialect.h"
+#include "mlir/Interfaces/DataLayoutInterfaces.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/Matchers.h"
 #include "mlir/Pass/Pass.h"
@@ -949,7 +950,11 @@ getMallocInModule(ModuleOp mod, fir::AllocMemOp op,
     return mlir::SymbolRefAttr::get(userMalloc);
 
   mlir::OpBuilder moduleBuilder(mod.getBodyRegion());
-  auto indexType = mlir::IntegerType::get(op.getContext(), 64);
+  // use target ptr width for malloc size (wasm32=32, x86_64=64)
+  mlir::DataLayout dl(op->getParentOfType<mlir::ModuleOp>());
+  auto ptrTy = mlir::LLVM::LLVMPointerType::get(op.getContext());
+  unsigned ptrBits = dl.getTypeSizeInBits(ptrTy);
+  auto indexType = mlir::IntegerType::get(op.getContext(), ptrBits);
   auto mallocDecl = moduleBuilder.create<mlir::LLVM::LLVMFuncOp>(
       op.getLoc(), mallocName,
       mlir::LLVM::LLVMFunctionType::get(getLlvmPtrType(op.getContext()),
@@ -974,22 +979,12 @@ getMalloc(fir::AllocMemOp op, mlir::ConversionPatternRewriter &rewriter) {
 static mlir::Value
 computeElementDistance(mlir::Location loc, mlir::Type llvmObjectType,
                        mlir::Type idxTy,
-                       mlir::ConversionPatternRewriter &rewriter) {
-  // Note that we cannot use something like
-  // mlir::LLVM::getPrimitiveTypeSizeInBits() for the element type here. For
-  // example, it returns 10 bytes for mlir::Float80Type for targets where it
-  // occupies 16 bytes. Proper solution is probably to use
-  // mlir::DataLayout::getTypeABIAlignment(), but DataLayout is not being set
-  // yet (see llvm-project#57230). For the time being use the '(intptr_t)((type
-  // *)0 + 1)' trick for all types. The generated instructions are optimized
-  // into constant by the first pass of InstCombine, so it should not be a
-  // performance issue.
-  auto llvmPtrTy = ::getLlvmPtrType(llvmObjectType.getContext());
-  auto nullPtr = rewriter.create<mlir::LLVM::ZeroOp>(loc, llvmPtrTy);
-  auto gep = rewriter.create<mlir::LLVM::GEPOp>(
-      loc, llvmPtrTy, llvmObjectType, nullPtr,
-      llvm::ArrayRef<mlir::LLVM::GEPArg>{1});
-  return rewriter.create<mlir::LLVM::PtrToIntOp>(loc, idxTy, gep);
+                       mlir::ConversionPatternRewriter &rewriter,
+                       const mlir::DataLayout &dataLayout) {
+  llvm::TypeSize size = dataLayout.getTypeSize(llvmObjectType);
+  unsigned short alignment = dataLayout.getTypeABIAlignment(llvmObjectType);
+  std::int64_t distance = llvm::alignTo(size, alignment);
+  return genConstantIndex(loc, idxTy, rewriter, distance);
 }
 
 /// Return value of the stride in bytes between adjacent elements
@@ -998,9 +993,10 @@ computeElementDistance(mlir::Location loc, mlir::Type llvmObjectType,
 static mlir::Value
 genTypeStrideInBytes(mlir::Location loc, mlir::Type idxTy,
                      mlir::ConversionPatternRewriter &rewriter,
-                     mlir::Type llTy) {
+                     mlir::Type llTy,
+                     const mlir::DataLayout &dataLayout) {
   // Create a pointer type and use computeElementDistance().
-  return computeElementDistance(loc, llTy, idxTy, rewriter);
+  return computeElementDistance(loc, llTy, idxTy, rewriter, dataLayout);
 }
 
 namespace {
@@ -1024,6 +1020,13 @@ struct AllocMemOpConversion : public fir::FIROpConversion<fir::AllocMemOp> {
     for (mlir::Value opnd : adaptor.getOperands())
       size = rewriter.create<mlir::LLVM::MulOp>(
           loc, ity, size, integerCast(loc, rewriter, ity, opnd));
+    // cast size to target malloc param type (e.g. i64->i32 for wasm32)
+    auto ptrTy = mlir::LLVM::LLVMPointerType::get(rewriter.getContext());
+    unsigned mallocTyWidth = getDataLayout().getTypeSizeInBits(ptrTy);
+    auto mallocTy =
+        mlir::IntegerType::get(rewriter.getContext(), mallocTyWidth);
+    if (mallocTyWidth != ity.getIntOrFloatBitWidth())
+      size = integerCast(loc, rewriter, mallocTy, size);
     heap->setAttr("callee", getMalloc(heap, rewriter));
     rewriter.replaceOpWithNewOp<mlir::LLVM::CallOp>(
         heap, ::getLlvmPtrType(heap.getContext()), size,
@@ -1037,7 +1040,7 @@ struct AllocMemOpConversion : public fir::FIROpConversion<fir::AllocMemOp> {
   mlir::Value genTypeSizeInBytes(mlir::Location loc, mlir::Type idxTy,
                                  mlir::ConversionPatternRewriter &rewriter,
                                  mlir::Type llTy) const {
-    return computeElementDistance(loc, llTy, idxTy, rewriter);
+    return computeElementDistance(loc, llTy, idxTy, rewriter, getDataLayout());
   }
 };
 } // namespace
@@ -1250,7 +1253,7 @@ struct EmboxCommonConversion : public fir::FIROpConversion<OP> {
                                    mlir::ValueRange lenParams) const {
     auto i64Ty = mlir::IntegerType::get(rewriter.getContext(), 64);
     mlir::Value size =
-        genTypeStrideInBytes(loc, i64Ty, rewriter, this->convertType(charTy));
+        genTypeStrideInBytes(loc, i64Ty, rewriter, this->convertType(charTy), this->getDataLayout());
     if (charTy.hasConstantLen())
       return size; // Length accounted for in the genTypeStrideInBytes GEP.
     // Otherwise,  multiply the single character size by the length.
@@ -1264,6 +1267,7 @@ struct EmboxCommonConversion : public fir::FIROpConversion<OP> {
   std::tuple<mlir::Value, mlir::Value> getSizeAndTypeCode(
       mlir::Location loc, mlir::ConversionPatternRewriter &rewriter,
       mlir::Type boxEleTy, mlir::ValueRange lenParams = {}) const {
+    const mlir::DataLayout &dataLayout = this->getDataLayout();
     auto i64Ty = mlir::IntegerType::get(rewriter.getContext(), 64);
     if (auto eleTy = fir::dyn_cast_ptrEleTy(boxEleTy))
       boxEleTy = eleTy;
@@ -1280,18 +1284,18 @@ struct EmboxCommonConversion : public fir::FIROpConversion<OP> {
         mlir::dyn_cast<fir::LogicalType>(boxEleTy) || fir::isa_real(boxEleTy) ||
         fir::isa_complex(boxEleTy))
       return {genTypeStrideInBytes(loc, i64Ty, rewriter,
-                                   this->convertType(boxEleTy)),
+                                   this->convertType(boxEleTy), dataLayout),
               typeCodeVal};
     if (auto charTy = mlir::dyn_cast<fir::CharacterType>(boxEleTy))
       return {getCharacterByteSize(loc, rewriter, charTy, lenParams),
               typeCodeVal};
     if (fir::isa_ref_type(boxEleTy)) {
       auto ptrTy = ::getLlvmPtrType(rewriter.getContext());
-      return {genTypeStrideInBytes(loc, i64Ty, rewriter, ptrTy), typeCodeVal};
+      return {genTypeStrideInBytes(loc, i64Ty, rewriter, ptrTy, dataLayout), typeCodeVal};
     }
     if (mlir::isa<fir::RecordType>(boxEleTy))
       return {genTypeStrideInBytes(loc, i64Ty, rewriter,
-                                   this->convertType(boxEleTy)),
+                                   this->convertType(boxEleTy), dataLayout),
               typeCodeVal};
     fir::emitFatalError(loc, "unhandled type in fir.box code generation");
   }
@@ -1836,7 +1840,7 @@ struct XEmboxOpConversion : public EmboxCommonConversion<fir::cg::XEmboxOp> {
       // We have a subcomponent. The step value needs to be the number of
       // bytes per element (which is a derived type).
       prevDimByteStride =
-          genTypeStrideInBytes(loc, i64Ty, rewriter, convertType(seqEleTy));
+          genTypeStrideInBytes(loc, i64Ty, rewriter, convertType(seqEleTy), getDataLayout());
     } else if (hasSubstr) {
       // We have a substring. The step value needs to be the number of bytes
       // per CHARACTER element.
diff --git a/flang/lib/Optimizer/CodeGen/Target.cpp b/flang/lib/Optimizer/CodeGen/Target.cpp
index 2a1eb0bc3..d6eeee09d 100644
--- a/flang/lib/Optimizer/CodeGen/Target.cpp
+++ b/flang/lib/Optimizer/CodeGen/Target.cpp
@@ -1656,6 +1656,41 @@ struct TargetLoongArch64 : public GenericTarget<TargetLoongArch64> {
 };
 } // namespace
 
+
+//===----------------------------------------------------------------------===//
+// WebAssembly (wasm32) target specifics.
+//===----------------------------------------------------------------------===//
+
+namespace {
+struct TargetWasm32 : public GenericTarget<TargetWasm32> {
+  using GenericTarget::GenericTarget;
+
+  static constexpr int defaultWidth = 32;
+
+  CodeGenSpecifics::Marshalling
+  complexArgumentType(mlir::Location, mlir::Type eleTy) const override {
+    assert(fir::isa_real(eleTy));
+    CodeGenSpecifics::Marshalling marshal;
+    auto structTy =
+        mlir::TupleType::get(eleTy.getContext(), mlir::TypeRange{eleTy, eleTy});
+    marshal.emplace_back(fir::ReferenceType::get(structTy),
+                         AT{/*alignment=*/4, /*byval=*/true});
+    return marshal;
+  }
+
+  CodeGenSpecifics::Marshalling
+  complexReturnType(mlir::Location loc, mlir::Type eleTy) const override {
+    assert(fir::isa_real(eleTy));
+    CodeGenSpecifics::Marshalling marshal;
+    auto structTy = mlir::TupleType::get(eleTy.getContext(),
+                                          mlir::TypeRange{eleTy, eleTy});
+    marshal.emplace_back(fir::ReferenceType::get(structTy),
+                          AT{/*alignment=*/4, /*byval=*/false, /*sret=*/true});
+    return marshal;
+  }
+};
+} // namespace
+
 // Instantiate the overloaded target instance based on the triple value.
 // TODO: Add other targets to this file as needed.
 std::unique_ptr<fir::CodeGenSpecifics>
@@ -1711,6 +1746,9 @@ fir::CodeGenSpecifics::get(mlir::MLIRContext *ctx, llvm::Triple &&trp,
   case llvm::Triple::ArchType::loongarch64:
     return std::make_unique<TargetLoongArch64>(
         ctx, std::move(trp), std::move(kindMap), targetCPU, targetFeatures, dl);
+  case llvm::Triple::ArchType::wasm32:
+    return std::make_unique<TargetWasm32>(
+        ctx, std::move(trp), std::move(kindMap), targetCPU, targetFeatures, dl);
   }
   TODO(mlir::UnknownLoc::get(ctx), "target not implemented");
 }
